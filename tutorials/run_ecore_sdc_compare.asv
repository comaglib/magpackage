% run_ecore_sdc_compare.m
% E-Core 变压器瞬态分析：BDF1 (基准) vs SDC (高阶) 对比测试

clear; clc;
fprintf('=========================================================\n');
fprintf('   Comparison: Standard BDF1 vs High-Order SDC           \n');
fprintf('=========================================================\n');

%% --- 1. 模型共享设置 (Mesh & Physics) ---
% 为了保证公平对比，两个求解器使用完全相同的物理模型

fprintf('[Setup] Loading Mesh and Materials...\n');
meshFile = 'data/Ecore.mphtxt';
if ~exist(meshFile, 'file'), error('Mesh file not found'); end
mesh = Mesh.load(meshFile, 'm'); 
mesh.generateEdges();

% 区域重映射
tags_primary = [5, 6, 8, 9]; tags_secondary = [3, 4, 7, 10];
tag_core = 2; tag_air = 1;
NEW_TAG_PRIM = 50; NEW_TAG_SEC = 60;
mesh.RegionTags(ismember(mesh.RegionTags, tags_primary)) = NEW_TAG_PRIM;
mesh.RegionTags(ismember(mesh.RegionTags, tags_secondary)) = NEW_TAG_SEC;

% 材料定义 (使用 v3.8 自动修正逻辑)
matLib = containers.Map('KeyType', 'double', 'ValueType', 'any');
B_data = [0, 0.1, 0.2, 0.3001, 0.4, 0.5001, 0.6001, 0.7, 0.8, 0.9001, 1, ...
          1.1001, 1.2001, 1.3002, 1.4, 1.4999, 1.5999, 1.6991, 1.7987, 1.8978, ...
          1.98, 1.9925, 2.118164];
H_data = [0, 7.86, 13.99, 19.51, 24.58, 29.42, 34.07, 38.64, 43.12, 47.59, 52.1, ...
          56.77, 61.67, 67.19, 74.03, 83.86, 1.00E+02, 1.38E+02, 2.95E+02, 1.01E+03, ...
          2500, 12500, 112500];
matLib(tag_core) = MaterialLib.createNonlinear(B_data, H_data); % 自动真空修正生效
matLinear = MaterialLib.createLinear(1.0);
matLib(tag_air) = matLinear; matLib(NEW_TAG_PRIM) = matLinear; matLib(NEW_TAG_SEC) = matLinear;

sigmaMap = containers.Map('KeyType', 'double', 'ValueType', 'double');
all_tags = unique(mesh.RegionTags);
for i = 1:length(all_tags), sigmaMap(all_tags(i)) = 0.0; end

% 空间与线圈
space_A = FunctionSpace('Nedelec', 1);
dofHandler = DofHandler(mesh);
dofHandler.distributeDofs(space_A);
space_P = FunctionSpace('Lagrange', 1);
dofHandler.distributeDofs(space_P);

[center, radius, area_S, axis_idx] = CoilGeometryUtils.autoDetectCircular(mesh, NEW_TAG_PRIM);
dir_map = -1.0 * CoilGeometryUtils.computeCircularDirection(mesh, NEW_TAG_PRIM, center, axis_idx);
winding = Winding('Primary', NEW_TAG_PRIM, 3000, 10, area_S, [0,0,0]);
winding.setDirectionField(dir_map);

circuit = struct();
circuit.R = 10; circuit.L = 0;
circuit.V_source_func = @(t) 500 * sin(2 * pi * 50 * t);

fixedDofs_A = BoundaryCondition.findOuterBoundaryDofs(mesh, dofHandler, space_A);
fixedDofs_P = BoundaryCondition.findOuterBoundaryDofs(mesh, dofHandler, space_P);

assembler = Assembler(mesh, dofHandler);
probePoint = [0, 0, 0]; % 铁芯中心探针

%% --- 2. 运行 BDF1 (Reference) ---
fprintf('\n[Run 1] Standard BDF1 Solver (Fine Step)...\n');
dt_bdf = 4e-4;           % 细步长
timeSim = 0.01;          % 跑 3 个周期 (50Hz -> 0.02s)
timeSteps_bdf = repmat(dt_bdf, round(timeSim/dt_bdf), 1);

tic;
solver_bdf = TransientCoupledSolver(assembler);
solver_bdf.Tolerance = 1e-3;
[~, info_bdf] = solver_bdf.solve(space_A, space_P, matLib, sigmaMap, ...
                                 circuit, winding, timeSteps_bdf, ...
                                 fixedDofs_A, fixedDofs_P, [], [], probePoint);
toc;

%% --- 3. 运行 SDC (High-Order) ---
fprintf('\n[Run 2] High-Order SDC Solver (Coarse Step)...\n');
% 策略: SDC 使用 P=3 阶多项式，每个时间片(Slab)包含 4 个节点。
% 为了公平对比计算量，我们将 Slab 长度设为 BDF1 步长的 4 倍。
% 这样虽然全局步数(Slab数)只有 BDF1 的 1/4，但内部有效计算点数相近。
dt_slab = 2e-3;          % 粗步长 (4x BDF)
timeSteps_sdc = repmat(dt_slab, round(timeSim/dt_slab), 1);

solver_sdc = SDCSolver(assembler);
solver_sdc.PolyOrder = 4;     % P=3 (4 nodes: 1 start + 3 internal)
solver_sdc.MaxSDCIters = 20;  % SDC 修正次数
solver_sdc.SDCTolerance = 1e-3;

% 注意: SDC 的 solve 接口与 TransientCoupledSolver 兼容
tic;
[~, info_sdc] = solver_sdc.solve(space_A, space_P, matLib, sigmaMap, ...
                                 circuit, winding, timeSteps_sdc, ...
                                 fixedDofs_A, fixedDofs_P, [], [], probePoint);
toc;

%% --- 4. 结果对比绘图 ---
fprintf('\n[Post] Plotting comparison...\n');

t_bdf = cumsum(timeSteps_bdf);
I_bdf = info_bdf.CurrentHistory;
B_bdf = info_bdf.ProbeB_History;

t_sdc = cumsum(timeSteps_sdc);
I_sdc = info_sdc.CurrentHistory;
B_sdc = info_sdc.ProbeB_History;

figure('Name', 'BDF1 vs SDC Comparison', 'Position', [200, 200, 1000, 600]);

% 子图 1: 电流对比
subplot(2, 1, 1);
plot(t_bdf*1e3, I_bdf, 'k-', 'LineWidth', 1.5, 'DisplayName', 'BDF1 (dt=0.1ms)');
hold on;
plot(t_sdc*1e3, I_sdc, 'r-o', 'LineWidth', 1.2, 'MarkerSize', 5, 'DisplayName', 'SDC (dt=0.4ms, P=3)');
grid on;
legend('Location', 'best');
xlabel('Time (ms)'); ylabel('Current (A)');
title('Comparision of Inrush Current');

% 子图 2: 磁密对比
subplot(2, 1, 2);
plot(t_bdf*1e3, B_bdf, 'k-', 'LineWidth', 1.5, 'DisplayName', 'BDF1');
hold on;
plot(t_sdc*1e3, B_sdc, 'b-d', 'LineWidth', 1.2, 'MarkerSize', 5, 'DisplayName', 'SDC');
grid on;
legend('Location', 'best');
xlabel('Time (ms)'); ylabel('|B| at Origin (T)');
title('Comparision of B-Field at Core Center');
% 
% % 误差分析
% % 由于时间点不同，取共有时间点 (Slab Endpoints) 计算误差
% common_indices = 4:4:length(I_bdf); % BDF 每 4 步对应 SDC 1 步
% if length(common_indices) > length(I_sdc), common_indices = common_indices(1:length(I_sdc)); end
% 
% I_bdf_sub = I_bdf(common_indices);
% I_sdc_sub = I_sdc(1:length(common_indices));
% 
% rel_err = norm(I_bdf_sub - I_sdc_sub) / norm(I_bdf_sub);
% fprintf('\n--- Accuracy Report ---\n');
% fprintf('Relative Error (Current) at Slab Nodes: %.2e%%\n', rel_err * 100);