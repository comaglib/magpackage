这是一个非常具有战略眼光的重构计划。你提出的**原则**（高性能、并行、DOD）与**建议**（混合架构）完美契合，而你关于**废弃 Biot-Savart 改用电流数值积分**的要求，更是将求解器从“教学玩具”推向“工业级通用求解器”的关键一步。

基于你的新要求，我为你设计了 **MagPackage v2.0** 的核心架构蓝图。



### 核心变革总结



1. **架构融合**：完全采纳 `架构建议.md`，实施 **"OOP Shell + DOD Kernel"（面向对象外壳 + 数据导向内核）** 模式。
2. **源项革命**：
   - **删除**：`compute_biot_savart_*` 系列函数。不再计算背景场 $B_s$ 或 $A_s$。
   - **引入**：`SourceIntegrator`。直接在有限元组装过程中，通过高斯积分计算电流密度 $J$ 对磁矢位 $A$ 的贡献：$\mathbf{F}_e = \int_{V_e} \mathbf{N} \cdot \mathbf{J} \, dV$。
   - **优势**：计算复杂度从 $O(N_{edges} \cdot N_{coil\_seg})$ 降低为 $O(N_{elems})$，且完全消除了 Biot-Savart 奇异性问题，物理含义更自然。

------



### 一、 新架构设计图 (MagPackage v2.0)



我们将代码分层为：**用户层 (OOP)** $\to$ **转换层 (Data Stripping)** $\to$ **内核层 (Parallel Kernels)**。



#### 1. 用户层：直观的 OOP 接口



用户不再操作裸数据，而是操作具有物理意义的对象。

Matlab

```
% 用户脚本示例
model = MagModel3D();

% 1. 网格与几何 (支持混入几何参数)
mesh = Mesh.load('motor.msh');
model.setMesh(mesh);

% 2. 定义源项 (The New Way: 基于空间的场描述)
% 方式 A: 基于区域 ID (自然、方便) -> 也就是常说的 "Stranded Coil Domain"
% 自动将 ID 为 5 的区域设为电流源，方向向量为 [0,0,1]，总安匝数为 1000
coilSource = CurrentSource.fromDomain(5, 'Direction', [0,0,1], 'Ampturns', 1000);

% 方式 B: 基于空间函数 (超灵活) -> 适合复杂形状线圈
% J_func 是一个函数句柄 @(x,y,z) ...
coilSource2 = CurrentSource.fromFunction(@(p) my_complex_coil_func(p));

model.addSource(coilSource);
model.addSource(coilSource2);

% 3. 求解
solver = HBFEMSolver(model); % 或 LinearSolver
solution = solver.solve();
```



#### 2. 转换层：数据剥离 (Data Stripping)



在进入 `solve()` 内部后，立即将对象“拆解”为纯数组。



#### 3. 内核层：放弃 Biot-Savart 的并行组装



这是重构的**核心**。我们将源项 ($J$) 视为一种特殊的材料属性，在单元循环中直接积分。

------



### 二、 核心代码重构方案



以下是基于 **混合架构** + **电流数值积分** 的具体实现代码骨架。



#### 1. 定义源项接口 (OOP Shell)



Matlab

```
classdef CurrentSource < handle
    properties
        Type        % 'Domain' or 'Function'
        RegionID    % for Domain type
        J_Vector    % [Jx, Jy, Jz] or FunctionHandle
    end
    
    methods
        function J_val = evaluate(obj, points, region_tag)
            % 输入: points [3 x N], region_tag
            % 输出: J_val [3 x N]
            J_val = zeros(3, size(points, 2));
            
            if strcmp(obj.Type, 'Domain') && region_tag == obj.RegionID
                % 简单的常数向量分布 (可扩展为螺旋等)
                J_val = repmat(obj.J_Vector(:), 1, size(points, 2));
            elseif strcmp(obj.Type, 'Function')
                J_val = obj.J_Vector(points); % 调用函数句柄
            end
        end
    end
end
```



#### 2. 高性能并行组装器 (The DOD Kernel)



这是替换原 `assemble_magnetic_stiffness.m` 和 `compute_biot_savart` 的全新内核。遵循你要求的并行、内存高效原则。

**主要变动**：

- 移除了 `BiotSavart` 调用。
- 在 `parfor` 内部增加了 RHS (右端项) 的积分计算。
- 使用了 `parallel.pool.Constant`。

Matlab

```
function [K_global, F_global] = assemble_system_kernel(Mesh, MatLib, Sources)
% ASSEMBLE_SYSTEM_KERNEL 并行组装刚度矩阵(K)与载荷向量(F)
% 纯函数设计，无对象依赖，数据完全解耦

    numElems = size(Mesh.T, 2);
    
    % --- 1. 数据准备 (Data Stripping) ---
    P_raw = Mesh.P;
    T_raw = Mesh.T;
    T2E_raw = Mesh.T2E;
    Sign_raw = Mesh.T2E_Sign;
    RegionTags = Mesh.RegionTags;
    
    % 将源项预处理为易于查找的结构 (Struct Array)
    % SourceMap: RegionID -> [Jx, Jy, Jz] (简化版，函数型源需传句柄)
    SourceData = preprocess_sources(Sources); 
    
    % --- 2. 建立广播变量 (Constant Pool) ---
    C_P = parallel.pool.Constant(P_raw);
    C_SourceData = parallel.pool.Constant(SourceData); 
    
    % --- 3. 预分配内存 (Block Strategy) ---
    blockSize = 50000; % 增大块大小以减少调度开销
    numBlocks = ceil(numElems / blockSize);
    
    % 仅存储非零元索引，不存储整个稀疏矩阵
    I_cell = cell(numBlocks, 1);
    J_cell = cell(numBlocks, 1);
    V_cell = cell(numBlocks, 1);
    F_cell = cell(numBlocks, 1); % 右端项部分
    
    % --- 4. 并行计算核心 (Parfor) ---
    parfor k = 1:numBlocks
        % A. 块切片 (Slicing) - 极低开销
        idx_start = (k-1)*blockSize + 1;
        idx_end = min(k*blockSize, numElems);
        indices = idx_start:idx_end;
        num_local = length(indices);
        
        loc_T = T_raw(:, indices);
        loc_T2E = T2E_raw(:, indices);
        loc_Sign = Sign_raw(:, indices);
        loc_Tags = RegionTags(indices);
        
        loc_P_all = C_P.Value;     % 零拷贝访问
        loc_Src = C_SourceData.Value; 
        
        % 预分配局部数组
        i_block = zeros(36 * num_local, 1);
        j_block = zeros(36 * num_local, 1);
        v_block = zeros(36 * num_local, 1);
        f_block = zeros(6 * num_local, 1);     % Edge elements RHS
        f_idx_block = zeros(6 * num_local, 1); % Edge indices for RHS
        
        ptr_K = 0; ptr_F = 0;
        
        % Gauss Quadrature (4点积分用于四面体)
        [q_pts, q_w] = get_quadrature_data_tet(1); 
        
        for e = 1:num_local
            % --- 几何计算 ---
            nodes = loc_T(:, e);
            verts = loc_P_all(:, nodes);
            [detJ, iJt] = compute_jacobian(verts);
            vol = abs(detJ) / 6.0;
            
            % --- 材料属性 (Nu) ---
            % (此处省略非线性查找，保留线性逻辑示例)
            nu = 1000; % 占位
            
            % --- K矩阵 (Curl-Curl) ---
            % 使用预计算的形函数旋度 (Constant Curl)
            Ke = compute_curl_curl_local(iJt, detJ, nu); 
            
            % 修正方向
            s = loc_Sign(:, e);
            Ke = Ke .* (s * s');
            
            % 填充 K
            edges = loc_T2E(:, e);
            [R, C] = meshgrid(edges, edges);
            range = ptr_K+1 : ptr_K+36;
            i_block(range) = R(:);
            j_block(range) = C(:);
            v_block(range) = Ke(:);
            ptr_K = ptr_K + 36;
            
            % --- F向量 (源项数值积分) ---
            % [核心变革] 直接积分: integral( N * J ) dV
            region_id = loc_Tags(e);
            J_vec = get_source_current(region_id, loc_Src); % [3x1]
            
            if any(J_vec)
                % 如果该单元有电流
                % 简单的一点积分 (Constant J inside element)
                % Fe_i = (Integral N_i) dot J
                % 对于 Nédélec 单元，N_i 是矢量基函数
                
                Fe = compute_element_current_load(verts, J_vec, iJt, detJ, s);
                
                range_f = ptr_F+1 : ptr_F+6;
                f_idx_block(range_f) = edges;
                f_block(range_f) = Fe;
                ptr_F = ptr_F + 6;
            end
        end
        
        % 裁剪未使用的内存
        I_cell{k} = i_block(1:ptr_K);
        J_cell{k} = j_block(1:ptr_K);
        V_cell{k} = v_block(1:ptr_K);
        
        % 聚合 F (注意：F是向量，需要特殊处理稀疏累加)
        % 为了效率，这里返回 index-value 对
        F_cell{k} = sparse(f_idx_block(1:ptr_F), 1, f_block(1:ptr_F), size(T2E_raw,1), 1); % Size invalid locally, adjusted later
        % 实际上 F_cell 最好存结构体 struct('idx',..., 'val', ...) 回主线程组装
        F_cell{k} = [f_idx_block(1:ptr_F), f_block(1:ptr_F)];
    end
    
    % --- 5. 主线程快速组装 (Reduce) ---
    % K 矩阵组装
    I = vertcat(I_cell{:});
    J = vertcat(J_cell{:});
    V = vertcat(V_cell{:});
    numEdges = max(Mesh.Edges(:)); % 需修正获取方式
    K_global = sparse(I, J, V, numEdges, numEdges);
    
    % F 向量组装
    F_all = vertcat(F_cell{:});
    if ~isempty(F_all)
        F_global = sparse(F_all(:,1), 1, F_all(:,2), numEdges, 1);
    else
        F_global = sparse(numEdges, 1);
    end
end

% --- 辅助函数：源项积分内核 ---
function Fe = compute_element_current_load(verts, J, iJt, detJ, signs)
    % 矢量形函数 N = (a_i + b_i x P) ... 
    % 简化：对于一阶 Nédélec 单元，Integral(N) * J 可以解析计算或数值积分
    % 这里演示中心点数值积分
    
    % N_ref at center (0.25, 0.25, 0.25)
    % 需要将参考坐标系的 N 变换到物理坐标系
    % N_phy = inv(J)' * N_ref
    
    % 为追求极速，这里通常展开成代数式
    % ... (详细的基函数积分公式)
    
    % 伪代码占位：
    Fe = zeros(6, 1);
    for i = 1:6
         % 物理基函数在重心的值
         N_vec_center = compute_shape_func_center(i, iJt); 
         Fe(i) = dot(N_vec_center, J) * (abs(detJ)/6.0); % Volume integral
    end
    Fe = Fe .* signs;
end
```



### 三、 优劣势分析 (基于你的原有代码 vs 新方案)



| **特性**     | **原方案 (Biot-Savart + Struct)**                 | **新方案 (电流积分 + Hybrid OOP/DOD)**                     | **评价**   |
| ------------ | ------------------------------------------------- | ---------------------------------------------------------- | ---------- |
| **源项处理** | **复杂**：需解析线圈几何，$O(N \cdot M)$ 计算量。 | **自然**：视作材料属性，仅需 $O(N)$。符合 "Natural" 要求。 | ✅ 极大提升 |
| **并行效率** | **受限**：Parfor 中通过对象或大切片传递数据。     | **极高**：Constant Pool + 纯数组切片。符合 `架构建议.md`。 | ✅ 极大提升 |
| **网格依赖** | **松耦合**：网格不需要拟合线圈。                  | **强耦合**：网格必须包含导电区域 (Conductor Domain)。      | ⚠️ 需注意   |
| **通用性**   | 仅支持简单形状线圈 (Racetrack/Circular)。         | 支持任意形状 (只要你能画出网格并定义 $J$ 方向)。           | ✅ 极大提升 |
| **内存占用** | 存储全场 $A_s$ 向量，内存大。                     | 仅组装右端项 $F$，几乎无额外内存。                         | ✅ 极大提升 |



### 四、 执行路线图



1. **废弃阶段**：
   - 删除 `src/sources/` 下所有关于 `racetrack`, `biot_savart` 的文件。
   - 保留 `coil` 仅作为生成 $J$ 向量的辅助工具，而不是求解器的一部分。
2. **构建 OOP 外壳**：
   - 创建 `Mesh`, `MaterialLib`, `PhysicsModel` 类。
   - 在 `PhysicsModel` 中实现 `addCurrentRegion(tag, J_vec)`。
3. **重写内核**：
   - 实现上述 `assemble_system_kernel`。
   - 编写 `compute_element_current_load`，确保矢量基函数的体积分正确（这部分数学推导需要小心，建议使用 Gauss 积分）。
4. **验证**：
   - 使用一个简单的螺线管模型。
   - 对比：理论解 vs 新的电流积分解。

这个方案完全满足你**“并行、高可扩展、高内存使用率、快速”**的原则，并且彻底解决了源项处理不自然的问题。现在，源项只是网格上的一个场而已。





---

---



这是一个非常具有野心但也非常符合现代 FEM 软件发展趋势的要求。将“有限元空间”与“求解变量”解耦，是实现多物理场耦合（如磁-热耦合、流-固耦合）以及高级电磁场算法（如 $A-V$ 形式、混合场形式）的必经之路。

结合你之前的**MagPackage v2.0**重构计划与**MagPackage v1.0**中已有的代码基础（特别是 `derive_kernels` 和 `kernel_generated` 目录，说明你已经有了符号计算生成内核的思路），我为你重新设计了 **MagPackage v3.0** 的完整架构。

------



### 一、 核心架构分析与合理性评估



**引入“独立有限元空间”的合理性：**

1. **物理本质的需求**：
   - **$V$ (电标势)**：自然属于 $H(\text{grad})$ 空间 $\to$ **节点元 (Nodal Elements)**。
   - **$\mathbf{A}$ (磁矢位)**：自然属于 $H(\text{curl})$ 空间 $\to$ **棱边元 (Edge Elements)**。
   - **$\mathbf{B}$ (磁通密度)**：自然属于 $H(\text{div})$ 空间 $\to$ **面元 (Face Elements)**。
   - **混合形式**：如果未来要做 $A-V$ 求解，必须在一个系统里同时处理 Edge DoFs 和 Nodal DoFs。
2. **对并行架构 (DOD) 的挑战**：
   - 之前的内核假设所有 DoF 都在 Edge 上，拓扑关系只有 `T2E`。
   - 现在，内核需要处理多组拓扑关系（`T2V` 节点, `T2E` 边, `T2F` 面）。
   - **对策**：必须引入 **`DofHandler` (自由度管理器)**，在进入并行计算前，将复杂的对象关系“扁平化”为对齐的整数数组。
3. **对源项积分的影响**：
   - 之前的源项积分只针对 Edge。现在源项可以施加在 Node 上（电荷密度）或 Edge 上（电流密度）。
   - **对策**：源项变成通用的 **`LinearForm`**，根据目标空间的基函数进行数值积分。

------



### 二、 MagPackage v3.0 完整重构方案





#### 1. 架构分层 (Layered Architecture)



我们依然采用 **OOP Shell + DOD Kernel** 的混合模式，但对 OOP 层进行了细化。

- **L1: 用户描述层 (User Interface)**
  - `Mesh`: 纯几何与拓扑。
  - `FunctionSpace`: 定义离散空间类型（如 `Lagrange_P1`, `Nedelec_Order1`）。
  - `TrialFunction` / `TestFunction`: 符号化的变量占位符。
  - `Form`: 描述物理方程（双线性形式 $a(u,v)$ 和 线性形式 $L(v)$）。
- **L2: 离散管理层 (Discretization Manager)**
  - **`DofHandler`**: 核心组件。负责遍历网格，为每个 `FunctionSpace` 生成全局 DoF 编号和单元 DoF 映射表 (`CellDofs`)。
  - `Assembler`: 负责数据剥离，准备并行数据，调用内核，最后组装稀疏矩阵。
- **L3: 计算内核层 (DOD Kernels)**
  - **`ShapeFunctionLib`**: 无状态的基函数求值库（支持 SIMD 或 向量化）。
  - **`IntegrationKernel`**: 并行执行的积分器。



#### 2. 用户代码预览 (The "FEniCS-like" MATLAB Experience)



Matlab

```
% 1. 网格
mesh = Mesh.load('motor.msh');

% 2. 定义有限元空间
V_h = FunctionSpace(mesh, 'Lagrange', 1); % 标量电势空间 (节点)
Q_h = FunctionSpace(mesh, 'Nedelec', 1);  % 矢量磁势空间 (边)

% 3. 定义变量
u = TrialFunction(Q_h); % 磁矢位 A
v = TestFunction(Q_h);  % 测试函数

% 4. 定义材料与源 (OOP方式)
mu_inv = MaterialProperty(mesh, 'mu_inv'); % 支持非线性或常数
J_src = CurrentSource(mesh, 'Region', 5, [0,0,1]); % 定义电流源

% 5. 定义变分形式 (Symbolic Description - 概念代码)
% 刚度项: (1/mu * curl A, curl v)
a = BilinearForm(InnerProduct(mu_inv * Curl(u), Curl(v))); 

% 源项: (J, v) - 自动数值积分，替代 Biot-Savart
L = LinearForm(InnerProduct(J_src, v)); 

% 6. 求解
solver = LinearSolver();
A_sol = solver.solve(a, L);
```



#### 3. 核心数据结构设计 (Data Stripping 关键)



为了在 `parfor` 中跑得快，`DofHandler` 必须生成以下结构体传入内核：

Matlab

```
% PackedData (传入 parfor 的纯数据)
PackedData.Mesh.P       % 节点坐标
PackedData.Mesh.T       % 单元节点连接

% 空间映射表 (Cell -> DoFs)
% 假设有两个空间: Space1(Edge), Space2(Node)
PackedData.Spaces(1).CellDofs  % [N_edges_per_elem x N_elems] (原 T2E)
PackedData.Spaces(2).CellDofs  % [N_nodes_per_elem x N_elems] (原 T)

% 积分所需数据
PackedData.Quadrature   % 积分点与权重
PackedData.MaterialValues % 预计算的材料参数
```

------



### 三、 详细执行路线图 (Step-by-Step Execution Plan)



考虑到你 v1.0 中已经有 `src/kernel_generated`，我们将充分利用这一点。



#### 第一阶段：基础组件重构 (OOP Shell & Mesh)



1. **Refactor `Mesh` Class**:
   - 目标：不仅支持 `read_msh`，还要能按需生成 `Edges`, `Faces` 信息。
   - 实现：将 v1.0 的 `build_topology` 封装进 `Mesh` 类。添加 `getEntities(dim)` 接口。
2. **Implement `FunctionSpace` & `DofHandler`**:
   - 目标：实现空间定义与 DoF 分配。
   - **Task 2.1**: 定义 `FunctionSpace` 类，包含属性 `Type` ('Lagrange', 'Nedelec') 和 `Order`。
   - **Task 2.2**: 实现 `DofHandler.distributeDofs(mesh, spaces)`.
     - 输出：生成 `DofMap` (Cell $\to$ Global Index)。
     - 测试：对于简单的四面体网格，验证 P1 空间的 DoF 数等于节点数，Nedelec 空间的 DoF 数等于边数。



#### 第二阶段：基函数与积分内核 (Kernel Evolution)



1. **Shape Function Library (L3)**:
   - 目标：编写独立的、无状态的基函数计算函数。
   - 代码结构：`src/fem/shape_functions/`
     - `nedelec_tet_p1.m`: 输入参考坐标 $(\xi, \eta, \zeta)$，输出 $\mathbf{N}$ 和 $\nabla \times \mathbf{N}$。
     - `lagrange_tet_p1.m`: 输入参考坐标，输出 $N$ 和 $\nabla N$。
   - **关键**：必须支持批量计算（Vectorized），即输入 $3 \times Q$ 个点，输出 $DoF \times 3 \times Q$ 的张量。
2. **Generic Assembly Kernel (Parallel)**:
   - 目标：编写一个通用的 `assemble_kernel`，替代原来硬编码的 `assemble_magnetic_stiffness`。
   - 逻辑：
     - 输入：`PackedData`, `KernelType` ('Stiffness', 'Mass')。
     - Parfor 内部：
       1. 取单元几何 $J, \det(J)$。
       2. 调用 `ShapeFunctionLib` 得到物理空间的基函数（需 Piola 变换）。
       3. 执行数值积分 $\sum w_q (\nabla \times \mathbf{N}_i) \cdot \mu^{-1} \cdot (\nabla \times \mathbf{N}_j)$。
       4. 填充局部矩阵。



#### 第三阶段：源项革命 (Source Integration)



1. **Implement `LinearForm` Assembler**:
   - 目标：废弃 Biot-Savart，使用积分法。
   - 实现：
     - 输入：`CurrentSource` 对象（包含 $J(x)$ 函数句柄或区域常数）。
     - 内核：对于每个单元，计算 $\mathbf{F}_e = \int \mathbf{N}_i \cdot \mathbf{J} \, dV$。
     - 注意：这里 $\mathbf{N}_i$ 是 Nedelec 基函数。



#### 第四阶段：整合与验证



1. **Verify with Standard Problems**:
   - 使用 TEAM 7 或简单的空心线圈模型。
   - 对比 v1.0 的结果。确保数值积分精度足够（通常需要 4 点或 5 点 Gauss 积分用于四面体）。

------



### 四、 针对高性能的特殊优化 (HPC Strategy)



在 MATLAB 中，如果让 `parfor` 内核过于通用（动态派发基函数类型），速度会急剧下降。为了满足你“快速”的要求，我建议采用 **代码生成 (Code Generation) / 静态绑定** 策略：

**策略：预生成特定组合的内核**

不要在循环里写：

Matlab

```
if space.type == 'Nedelec'
   val = compute_nedelec(...)
end
```

而是保留你 v1.0 中的 `src/kernel_generated` 模式，但对其升级：

1. 创建一个 **Kernel Registry**。
2. `Assembler` 根据用户定义的 Form（例如 CurlCurl + Nedelec P1），**选择** 调用特定的硬编码函数（如 `kernel_curlcurl_nedelecP1.m`）。
3. 这个硬编码函数内部是完全展开的代数运算，没有任何 `if/else` 判断，也没有函数句柄调用，直接针对数组操作。

结论：

v3.0 方案将在 OOP 层提供极高的灵活性（任意空间组合），但在执行层（DOD）回退到高度优化的、针对特定单元类型生成的数值代码。这完美平衡了扩展性与性能。

下一步建议：

如果通过，我们可以从 Step 1: Refactor Mesh & Implement DofHandler 开始。这是所有后续工作的基础。

